package gov.lanl.archive.resource;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Vector;
import java.util.TimeZone;
import java.util.concurrent.atomic.AtomicInteger;

import gov.lanl.archive.ArchiveConfig;
import gov.lanl.archive.Memento;
import gov.lanl.archive.Index;
import gov.lanl.archive.unload.DbWarcWriter;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriInfo;

import org.archive.io.WriterPoolMember;
import org.archive.io.WriterPoolSettings;
import org.archive.io.arc.ARCConstants;
import org.archive.io.warc.WARCWriter;
import org.archive.io.warc.WARCWriterPool;


/*
@author Lyudmila Balakireva
*/
@Path("/warcunload/{date}/{id:.*}")

public class WARCUnloadResource {
	  private static Index idx;
	  static WARCWriterPool pool;
	  static DbWarcWriter wr;
	  final static int MAX_ACTIVE = 3;
	  final static int MAX_WAIT_MILLISECONDS = 2000;
	  MementoCommons mc;
	  protected final URI baseUri;
	   public static final String DB_PATH =
	         System.getProperty( "ta.storage.basedir", "target/db" );
	   
	  static {
	       
		   
	        idx = ArchiveConfig.getMetadataIndex();
	   	    pool = new  WARCWriterPool(new AtomicInteger(), getSettings(true), MAX_ACTIVE,  MAX_WAIT_MILLISECONDS);
	   	    wr = new DbWarcWriter();
	    }
	  
	  public	WARCUnloadResource( @Context UriInfo uriInfo )
	    {
	        this.baseUri = uriInfo.getBaseUri();
	        mc = new MementoCommons(baseUri);
	            System.out.println("init");
	    }
	 
	 
	  @GET
/*
        public Response UnloadSelected(@PathParam("id") String id,@PathParam("date") String date) {
		  try {
			  
			  Date untildate = mc.checkMementoDateValidity(date);
			  long nowLong = untildate.getTime();
	          String datestr = Long.toString(nowLong);
			  List  combo = idx.getUntil(datestr,null);
			  List  keys = ( List <String>) combo.get(0);
			  List <Memento> mems =(List <Memento>) combo.get(1);
			  WriterPoolMember writer =pool.borrowFile();
			
			  WARCWriter w = (WARCWriter)writer;
			  
			 while(mems!=null) {
				String lastkey = WriteBunch (mems, w);
				if (keys.size() < 3 ) { break; }
				  combo = idx.getUntil(datestr,lastkey);
				   keys = ( List <String>) combo.get(0);
				   mems =(List <Memento>) combo.get(1);
				
			 }
			  
			  w.close();
		        pool.returnFile(w);
			
			
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} 
		  
		  
        return null;	
        }
*/
	  
      public Response UnloadSelected(@PathParam("id") String id,@PathParam("date") String date) {
		  try {
			  
			  Date untildate = mc.checkMementoDateValidity(date);
			  long nowLong = untildate.getTime();
	          String datestr = Long.toString(nowLong);
			  List<Memento>  lm = idx.getUntil(datestr,null);
			  System.out.println("selected list" +lm.size());
		//	  List  keys = ( List <String>) combo.get(0);
			//  List <Memento> mems =(List <Memento>) combo.get(1);
			  WriterPoolMember writer =pool.borrowFile();
			
			  WARCWriter w = (WARCWriter)writer;
			  int count=0;
		
				  for (Memento r:lm) {
				   //is it dupid unique key
			    
			        count = count+1;
			   	    //wr.writeRecords( w, r);
			   	   if (count>2) break;
			   	    try {
						w.checkSize();
					} catch (IOException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
			  }
			  
			  
			  
			
			  
			  w.close();
		        pool.returnFile(w);
			
			
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} 
		  
		  
      return null;	
      }
	  
	  
	  
	  
	public String WriteBunch (List <Memento> mems, WARCWriter w) {
		String lastkey = null;
		int count=0;
		  for(Memento r:mems){
			   //is it dupid unique key
		        lastkey = r.getUrl();
		        count =count+1;
		   	    wr.writeRecords( w, r);
		   	   if (count>4) break;
		   	    try {
					w.checkSize();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
		  }
		  return lastkey;
	}
	  
	  
	  public static WriterPoolSettings getSettings(final boolean isCompressed) {
	        return new WriterPoolSettings() {
	            public long getMaxSize() {
	                return ARCConstants.DEFAULT_MAX_ARC_FILE_SIZE;
	            }
	            
	            public String getPrefix() {
	                return "MEM";
	            }
	            
	            public String getSuffix() {
	                return "SUF";
	            }
	            
	            public List<File> getOutputDirs() {
	            	
	               File arcdir = new File(System.getProperty( "warcfiles.unload.dir", DB_PATH  + File.separator+"warcfiles"));
	               File [] files = {arcdir};
	                return Arrays.asList(files);
	            }
	            
	            public boolean isCompressed() {
	                return isCompressed;
	            }
	            
	            public List getMetadata() {
	            	  List <String> list = new ArrayList();
	      	    	list.add("format:WARC File Format 1.0\n");
	      	    	list.add("conformsTo:http://bibnum.bnf.fr/WARC/WARC_ISO_28500_version1_latestdraft.pdf\n");
	      	    	list.add("operator:tr-achive");
	      	    	return list;
	            }
	          	
	        };
	  }
}
